* slang
** pre-requirements
- `llvm`. this project use llvm as compiler backend. 
- `stack`, to setup ghc, downloads all dependencies, build the compiler, etc.

#+BEGIN_SRC bash
  brew install llvm-hs/llvm/llvm-8
  curl -sSL https://get.haskellstack.org/ | sh # https://docs.haskellstack.org/en/stable/README/
#+END_SRC

** the compile process 

**.sl -> haskell-ast -> llvm ir -> all the format llvm supports

** how to run
#+BEGIN_SRC bash
  stack build
  stack install # after this step , stack will install slc to the bin path you configigured. (normally, it's ~/.local/bin/, make sure this is in your path config)
  slc sl-data/test.sl
  lli-8 sl-data/test.ll # if lli-8 don't exists, check the path and homebrew
#+END_SRC
you can always check the `*.ll` file for more compile details
** step one
- [X] finish simple s-expression parser
- [X] add arithmetic(such as `+`, `-`, `*`, `/`) support
  - run `/usr/local/Cellar/llvm-8/8.0.0/bin/lli-8 ./sl-data/test.ll` to see the return code...
  - use printf to show result of top level instuctions
- [X] compile to llvm

** step two
- [ ] add top level function define
- [ ] add more primitive functions 
  - export from stdio/libc

** step three
- [ ] add control flow
- [ ] jit (mostly already supported by llvm)
- [ ] explore optimations supported by llvm

** step four
- [ ] experiment `type` system and other fantastical possibilities
- [ ] runtime system
- [ ] lock, thread, so on...

** step five
- [ ] gc...  :: seems a long way to me
